\documentclass[paper=a4, fontsize=9pt]{article}
\usepackage[utf8]{inputenc}

\usepackage[a4paper]{geometry}
\geometry{top=2cm, bottom=2cm, left=2cm, right=2cm}
\setlength{\parskip}{2mm}

\usepackage{lipsum}

\usepackage[spanish]{babel}										
\usepackage[protrusion=true,expansion=true]{microtype}		    % Better typography
\usepackage{amsmath,amsfonts,amsthm}					                % Math packages
\usepackage[pdftex]{graphicx}									                % Enable pdflatex
\usepackage[svgnames]{xcolor}									                % Enabling colors by their 'svgnames'
\usepackage[hang, small, labelfont=bf,up,textfont=it,up]{caption}	% Custom captions under/above floats
\usepackage{epstopdf}											  	                % Converts .eps to .pdf
\usepackage{subfig}												  	                % Subfigures
\usepackage{wrapfig}
\usepackage{float}
\usepackage{booktabs}											  	                % Nicer tables
\usepackage{fix-cm}												  	                % Custom fontsizes
\usepackage{hyperref}                                         % Link Clicks
\usepackage{filecontents}



%opening
\title{Métodos estadísticos aplicados al baloncesto}
\author{Paula Moreno Blazquez}
\date{Enero 2022}

\begin{document}
\SweaveOpts{concordance=TRUE}

\maketitle

\clearpage

\begin{abstract}

Hoy en día, el deporte es un hobby muy popular por todo el mundo. Des de pequeños, los niños practican algún tipo de deporte, especialmente aquellos que son de equipo. Eso nos lleva a querer saber más del deporte, más detalles, más información. Nos entra la curiosidad de "¿quién es el mejor jugador?", "Qué equipo es mejor?", o incluso intentar prevenir qué equipo ganará según sus resultados anteriores. Y gracias a los avances tecnológicos e informáticos, cada vez se nos facilita más poder seguir un deporte des de casa, ver la estadística de los deportistas e incluso hay plataformas o juegos que nos permiten ser, de manera virtual, managers de los clubs y, por lo tanto, nos facilitan mucha información que antes era más difícil de saber.

Eso hace que, de manera progresiva, también mejore el estudio y el análisis de cada deporte, y cada vez sea más específica para cada deporte, implementando nuevos recursos para mejorar los resultados. Pero, ¿son lo suficientemente eficaces los análisis que se realizan actualmente en Europa? ¿O dichos análisis estan anticuados y requieren de una actualización?

\end{abstract}

\pagebreak            
\newpage              

\tableofcontents

\clearpage



\section{Introducción}

En este trabajo estudiaremos más a fondo el Baloncesto, el segundo deporte más popular de Europa (solo superado por el futbol), y el cual tengo interés personal, ya que lo practico des de los 4 años.

Esta idea de estudio surgió del constante pensamiento de que los análisis actuales que se hacen en este deporte en Europa son bastante pobres a nivel informativo, puesto que se basan en conceptos muy básicos, y principalmente ofensivos (que vendría a ser el 50\% de un partido). Para que nos hagamos una idea, el estadístico por preferencia es el llamado \emph{Valoración} y que se originó en 1991 (hace 30 años) y des de entonces nunca se ha modificado.

Es por eso que, considero que actualmente los análisis que se hacen de este deporte necesitan una actualización significativa para llegar a informar de todos aquellos datos que hoy en día si se pueden recoger gracias a los avances tecnológicos, y de los cuales no se analizan por falta de dinero o porque se consideran poco relevantes.

El objetivo principal de este estudio es mejorar los análisis que se elaboran de cada partido, para poder encontrar una variable respuesta que nos diga que aportación al equipo tiene cada jugador personalmente, disminuyendo la diferencia de pesos que hay actualmente entre las aportaciones ofensivas y las aportaciones defensivas.

Este documento se estructura de la siguiente manera: a continuación, se realizará una breve explicación de los recursos informáticos que se han utilizado para realizar este estudio, seguidamente se explicará brevemente los conceptos de baloncesto que son necesarios para entender los tecnicismos del trabajo y se presentaran posibles análisis que se realizan. Finalmente, se describirá la base de datos con la que se ha trabajado y sus variables, y también se explicará en profundidad el análisis que se desarrollará en este trabajo, el Más/Menos Ajustado (\emph{Adjusted Plus/Minus, APM}). En la sección de resultados presentaremos la resolución del análisis y finalmente discutiremos, en la sección de conclusiones, los resultados obtenidos.

\section{¿Qué es GitHub?}

\begin{wrapfigure}{r}{0.25\textwidth} %this figure will be at the right
    \centering
    \includegraphics[width=0.25\textwidth]{imagenes/GitHub-Logo.png}
\end{wrapfigure}

GitHub es una plataforma de alojamiento, propiedad de Microsoft, que ofrece a los desarrolladores la posibilidad de crear repositorios de código y guardarlos en la nube de forma segura, usando un sistema de control de versiones, llamado Git.

Como he comentado, facilita la organización de proyectos y permite la colaboración de varios desarrolladores en tiempo real. Es decir, nos permite centralizar el contenido del repositorio para poder colaborar con los otros miembros de nuestro grupo des de varios dispositivos.

GitHub está basada en el sistema de control de versiones distribuidas de Git, por lo que se puede contar con sus funciones y herramientas, aunque GitHub ofrece varias opciones adicionales y su interfaz es mucho más fácil de manejar, por lo que no es absolutamente necesario que las personas que lo utilizan tengan un gran conocimiento técnico.

\subsection{Ventajas}

Hay un gran número de razones por las que GitHub es una gran opción para el control y gestión de proyectos de código. Como por ejemplo:
  
  \begin{itemize}

\item GitHub permite que alojemos proyectos en repositorios de forma gratuita
\item Los repositorios son públicos por defecto. Sin embargo, GitHub te permite también alojar tus proyectos de manera privada
\item Puedes crear y compartir páginas web estáticas con GitHub Pages
\item Facilita compartir tus proyectos de una forma mucho más fácil y crear un portafolio
\item Te permite colaborar para mejorar los proyectos de otros y a otros mejorar o aportar a los tuyos
\item Ayuda reducir significativamente los errores humanos y escribir tu código más rápido con GitHub Copilot
\item Te da control de versiones, una herramienta muy útil.

\end{itemize}

\subsection{¿Qué es el control de versiones?}

Se le llama control de versiones a la administración de los cambios que se realizan sobre los elementos o la configuración de algún proyecto. En otras palabras, el control de versiones sirve para conocer y autorizar los cambios que hagan los colaboradores en tu proyecto, guardando información extra de qué están, incluyendo los cambios y cuándo se hicieron. Este control comienza con una versión básica del documento y luego va guardando los cambios que se hagan a lo largo del proyecto.

El control de versiones es una herramienta muy valiosa, pues con ella puedes tener acceso a las versiones anteriores de tu proyecto si es que en algún momento no llega a funcionar de forma correcta.

\subsection{¿Qué es Git?}

Git es un software de control de versiones diseñado por Linus Torvalds, pensando en la eficiencia, la confiabilidad y compatibilidad del mantenimiento de versiones de aplicaciones cuando estas tienen un gran número de archivos de código fuente.

\subsubsection{Diferencias Git vs GitHub}

Entonces, ¿qué diferencia a Git de GitHub? La principal diferencia es que Git es un sistema que permite establecer un control de versiones, mientras que GitHub es una plataforma que ofrece un grupo de funciones que facilitan el uso de Git y la colaboración en tiempo real, así como el almacenamiento en la nube.

\section{El baloncesto}

\subsection{Historia y reglas básicas}

\begin{wrapfigure}{r}{0.3\linewidth}
    \centering
    \includegraphics[width=0.3\textwidth]{imagenes/historia_baloncesto.jpg}
    \label{fig:hist_bskb}
\end{wrapfigure}

El baloncesto es un deporte de equipo que se originó en 1891, por James Naismith, profesor de educación física en la escuela YMCA de Springfield, Massachusetts, Estados Unidos.

James buscaba idear un deporte que sus alumnos pudieran practicar bajo techo, pues los duros inviernos en Massachusetts dificultaban la realización de ejercicio al aire libre, por lo que inventó el baloncesto utilizando unas cajas de melocotones y unos balones. 

Con el paso de los años, este deporte, que empezó como actividad de colegio, ha ido evolucionando mucho, añadiendo más reglas, conceptos nuevos, límites de números de jugadores, se ha determinado tiempos de juego, las canastas tienen un valor distinto según la distancia, etc.

Actualmente, las normas más básicas de este deporte son:
  
\begin{itemize}

  \item En las ligas superiores, hay un total de 4 cuartos de 10 minutos y pueden estar en pista 5 jugadores por equipo.
  \item No te puedes desplazar con la pelota en las manos, es obligatorio botar con una mano (si no será una infracción y conllevará la perdida de pelota y saque de banda del equipo rival).
  \item Cada jugador puede realizar hasta un total de 5 faltas, que será penalizado con un saque de banda o con un tiro libre (dependerá de la situación). El jugador que realiza 5 faltas será expulsado del partido.
  \item El objetivo es encestar el máximo de puntos posibles, teniendo en cuenta que pueden sumar 1, 2 o 3 puntos, según la distancia.

\end{itemize}

\clearpage

\subsection{Conceptos y definiciones básicas del baloncesto:}

Para que podamos entender a que nos referimos en este trabajo, es necesario comprender unos conceptos básicos de vocabulario. Tendremos en cuenta los conceptos que se necesitan para realizar la valoración del jugador y/o del equipo que se utilizan en las estadísticas federadas.

\begin{itemize}

\item Puntos: Acumulación de tiros encestadas multiplicadas por su valor, que cada  jugador y/o equipo realiza durante el partido
\item Minutos: Número de minutos que el jugador está en pista
\item Falta: Acción en la que un defensor bloquea el avance de su rival sin tener control de balón o de manera no reglamentaria (empujar, agarrar...)
\item Pérdidas de balón: cuando un equipo pierde el control del balón y pasa a ser del equipo rival.
\item Rebotes: Recuperación de pelota después de que el tiro sea ejecutado, pero no haya encestado.
\item Recuperación de balón: Cuando un equipo consigue robar el balón al equipo rival.
\item Asistencia: Es un pase a un jugador que se encuentra en una posición de ventaja o que le ayuda a conseguir una canasta sin hacer ningún bote.
\item Tapón: Bloqueo de un tiro en el aire.

\end{itemize}

\section{Posibles análisis realizables en el baloncesto}

Viendo la gran cantidad de datos que se pueden extraer de cada partido (y de cada equipo), se han ido creando análisis que recogen estos datos y los analizan para ayudarnos a identificar y desarrollar hipótesis sobre cada jugador y/o equipo.

\subsection{Boxscore}

El primer análisis que se hizo fue un \emph{Box Score} (Caja de puntuación) donde se recopilaba únicamente los puntos de cada jugador según el valor de esta y las faltas realizadas. Posteriormente, se fue mejorando añadiendo conceptos como rebotes, tapones, perdidas de balón, recuperaciones de balón... Y se añadió el estadístico (que acutalmente es por defecto) que se realiza a partir de todos estos datos: \emph{Valoración} (en inglés PIR, \emph{Performance Index Rating}) que engloba todo lo básico que pasa en el partido de manera individual y que, cuanto más positivo, mejor. Este estadístico se calcula utilizando la siguiente fórmula:
  
\begin{equation} \label{eq1}
  \begin{split}
  PIR = & (Puntos + Rebotes + Asistencias + Robos + Tapones + Faltas Recibidas) - \\
  & (Tiros de Campo Fallados + Tiros Libres Fallados + Tapones Recibidos + Pérdidas + Faltas Realizadas)
  \end{split}
\end{equation}

\centerline{(en el \hyperref[sec:Annexo1]{Annexo 1} encontraréis la descripción de cada variable)}

\vspace{0.2cm}

Posteriormente, se añadió la variable "Más/Menos" (\emph{P/M, Plus/Minus}) que tiene que ver con la diferencia de puntos en el marcador durante el tiempo que el jugador esté en pista. Esta variable sirve para ver la contribución de los jugadores cuando están en pista. Todos los jugadores parten inicialmente con un 0, y según van entrando y saliendo de la pista, esta variable se va actualizando. Por ejemplo, los jugadores que son del quinteto inicial, empiezan con el marcador 0 - 0, y un $P/M = 0$. Si en el minuto 5, se substituye un jugador en cancha del equipo local (J1) por otro que está descansando (J2), y el marcador va 12 - 7, el $P/M$ del J1 pasará a ser $+5$. Y si al cabo de 3 minutos, se sustituye el J2 por otro (J3) y el marcador ahora va 20 - 9, el $P/M$ del J2 será $+6$ ($(20-12) - (9-7) = 8 - 2 = +6$).

\begin{figure}[H]
\centering
\begin{minipage}{.5\textwidth}
\centering
\captionsetup{width=.8\linewidth}
\includegraphics[width=.8\linewidth]{imagenes/BoxScore1962.jpg}
\captionof{figure}{Boxscore del partido de la NBA de Philadelphia Warriors contra New York Knicks, del 2 de Marzo de 1962}
\label{fig:BoxScore1962}
\end{minipage}%
\begin{minipage}{.5\textwidth}
\centering
\captionsetup{width=.8\linewidth}
\includegraphics[width=.7\linewidth]{imagenes/BoxScore2022.jpg}
\captionof{figure}{Boxscore del partido de la Euroliga de Real Madrid contra FC Barcelona, del 11 de Febrero del 2022}
\label{fig:BoxScore2022}
\end{minipage}
\end{figure}

Aunque un \emph{Box Score} es muy útil para realizar análisis básicos, ya que es muy visual y cualquier persona sin la necesidad de muchos recursos puede analizar y predecir ciertos valores, pero estadísticamente perdemos una parte importante de la información de los datos, puesto que no nos los muestra progresivamente, sino que nos da los valores acumulados al final del tiempo establecido, y muchas veces contiene información engañosa, especialmente en las estadísticas defensivas.

Por lo que, para el desarrollo temporal del partido y para conocer cierta información de equipo que piden entrenadores y clubs, no nos sirve (como por ejemplo la eficacia de los quintetos, el desarrollo del marcador o de cualquier otra variable del equipo entero durante un tiempo determinado del partido, etc.)



\subsection{Play-by-play}

\begin{wrapfigure}{r}{0.4\linewidth}
    \centering
    \includegraphics[width=0.4\textwidth]{imagenes/PBP_RM.png}
    \captionsetup{width=.9\linewidth}
    \captionof{figure}{\emph{Play by play} del partido de la Euroliga de Real Madrid contra LDLC Asvel, del 17 de Marzo del 2022. Se lee de abajo hacia arriba.}
    \label{fig:PBP_RM}
\end{wrapfigure}

Este tipo de recogida de información se creo para solucionar el problema que teniamos con el \emph{Box Score}. Los datos de \emph{Play-by-Play (PBP)} han sido la fuente principal de muchas estadísticas avanzadas, como el más-menos ajustado, que se desarrollará en este trabajo.

\emph{Play-by-Play} proporciona una transcripción del juego en un formato de eventos individuales. Los datos típicos de jugada por jugada deben tener la siguiente información:
  
  \begin{itemize}
\item El tiempo de la posesión
\item El jugador que inició la posesión (en caso de robo o rebote defensivo)
\item El jugador contrario que inició la posesión (en caso de un tiro fallado o pérdida de balón), incluida la ubicación en el piso desde donde se realizó el tiro y algunos otros identificadores únicos que usamos para clasificar el tipo de posesión.
\end{itemize}

Este tipo de análisis se inicializaron en 2007 para la Euroliga (principal competición europea de baloncesto) y en 2012 para la Eurocopa (competición internacional de segundo nivel).

\clearpage

\subsection{Shot-charts}

Este tipo de análisis es de los más visuales, ya que se realiza de una manera muy sencilla: se tiene como plantilla el dibujo de una pista de baloncesto de manera vectorial, y se va colocando cada tiro realizado en la posición del tiro, el jugador y si se encesta o no. De forma general se hace escribiendo el número del jugador en la posición des de donde se ejecuta el tiro, y si encesta, se hace un círculo alrededor del número.

El \emph{Shot-Charts}, proporciona un output visual muy fácil de interpretar, ya que es se parece a un mapa de calor y, por lo tanto, podemos observar de una manera muy rápida des de que zonas de la pista es más efectivo el equipo y/o el jugador.

Una vez realizado, podemos obtener con facilidad el porcentaje de acierto del equipo y/o el jugador, o incluso, determinar el porcentaje de acierto por zonas.

De este análisis, es frecuente encontrar variantes: mapa de calor del equipo, mapa de porcentajes de aciertos por zonas de la pista...

\subsection{Graphic Stats}




\clearpage

\section{Estadístico Más/Menos (\emph{Plus/Minus})}

\subsection{Normal Plus Minus, PM}

\subsection{Adjusted Plus Minus, APM}

\subsection{Regularized Adjusted Plus/Minus, RAPM}

\subsection{Real Plus-Minus, RPM}

(explicar cada concepto y su manera de calcularlo o en base a que se calcula)

Tabla de diferencias ?

\clearpage

<<include=FALSE, echo=FALSE>>=
library(readr)
library(dplyr)
library(ggplot2)
library(here)
library(tidyverse)
library(tidyr)
library(dplyr)
library(chron)                 # Para CHR_to_seconds
library(stringr)               # Para str_pad
library(lubridate)
library(reshape)
library(tidyselect)
library(corrplot)
library(RColorBrewer)
library("colorspace")
library(graphics)
library(rpart)
library(ggplot2)
library(car)                   # VIF

#ERROR SOLUCION
pbp_2008 <- read_csv("pbp2008.csv")

## Check how many rows are affected by this
bad_lineups <- pbp_2008 %>%
  select(matches("_player[1-5]")) %>%
  apply(1, function(x) max(table(x)) > 1)

pbp_bad <- pbp_2008 %>%
  filter(bad_lineups)
    
pbp_bad %>%
  select(season, game_code, play_number, play_type, away_player4, away_player5)
    
## Solucion
source(here("R", "fix-lineups.R"))

## Function fix_lineups() only takes data from a single game,
## so I split the data and apply the function to each splitted data frame.
pbp_2008_fixed <- split(pbp_2008, factor(pbp_2008$game_code)) %>%
  map_df(fix_lineups) 

pbp_2009 <- read_csv("pbp2009.csv")
pbp_2009_fixed <- split(pbp_2009, factor(pbp_2009$game_code)) %>%
  map_df(fix_lineups) 

pbp_2010 <- read_csv("pbp2010.csv")
pbp_2010_fixed <- split(pbp_2010, factor(pbp_2010$game_code)) %>%
  map_df(fix_lineups) 

pbp_2011 <- read_csv("pbp2011.csv")
pbp_2011_fixed <- split(pbp_2011, factor(pbp_2011$game_code)) %>%
  map_df(fix_lineups) 

pbp_2012 <- read_csv("pbp2012.csv")
pbp_2012_fixed <- split(pbp_2012, factor(pbp_2012$game_code)) %>%
  map_df(fix_lineups) 

pbp_2013 <- read_csv("pbp2013.csv")
pbp_2013_fixed <- split(pbp_2013, factor(pbp_2013$game_code)) %>%
  map_df(fix_lineups) 

pbp_2014 <- read_csv("pbp2014.csv")
pbp_2014_fixed <- split(pbp_2014, factor(pbp_2014$game_code)) %>%
  map_df(fix_lineups) 

pbp_2015 <- read_csv("pbp2015.csv")
pbp_2015_fixed <- split(pbp_2015, factor(pbp_2015$game_code)) %>%
  map_df(fix_lineups) 

pbp_2017 <- read_csv("pbp2017.csv")
pbp_2017_fixed <- split(pbp_2017, factor(pbp_2017$game_code)) %>%
  map_df(fix_lineups) 

pbp_2018 <- read_csv("pbp2018.csv")
pbp_2018_fixed <- split(pbp_2018, factor(pbp_2018$game_code)) %>%
  map_df(fix_lineups) 

pbd_datos_fixed <- pbp_2008_fixed

factor_names <- c('season', 'game_code', 'team_code', 'play_number', 'play_type')
pbd_datos_fixed[,factor_names] <- lapply(pbd_datos_fixed[,factor_names] , factor)

summary(pbd_datos_fixed[1:18])

#CATEGORIZACION BBDD
df <- pbd_datos_fixed
N_df <- dim(df)[1] # Numero de jugadas
M_df <- dim(df)[2] # Numero de variables

df_fact <- df %>%
  select(season, game_code, team_code, player_name, team_name) %>%
  mutate(season = as.factor(season),
         team_code = as.factor(team_code),
         player_name = as.factor(player_name),
         team_name = as.factor(team_name))

num_teams <- length(levels(df_fact$team_name)) # Numero de equipos

players <- df %>% 
  select(matches("player_name")) %>%
  arrange(player_name) %>% 
  unique() %>% 
  drop_na()

players <- players$player_name
num_players <- length(players)   # Numero de jugadores

df_pbp <- df %>% 
  select(season, game_code, quarter, seconds, points_home, points_away, home_team, away_team, matches("_player[1-5]"))

CHR_to_seconds <- function(x){
  a <- as.POSIXct(x, tz = '', format = "%H:%M:%S", usetz = FALSE)
  tms <- secondss(format(a, "%H:%M:%S"))
  s <- period_to_seconds(hms(tms))
  return(s)
}

Print_MS <- function(x){
  t <- seconds_to_period(x)
  sprintf('%02d:%02d:%02d', t@hour, minute(t), second(t))
}

TP_home <- df_pbp %>%
  select(c(contains("home_"))) %>%
  unique()

TP_away <- df_pbp %>%
  select(c(contains("away_"))) %>%
  unique()

CBIND_MultipleCol_n <- function(data,col,n){
  d <- unlist(data[col])
  x <- cbind(rep(d, n))
  y <- unlist(data[-1])

  res <- cbind(x, y)
  rownames(res) <- NULL
  
  res <- unique(res)
  
  return(res)
}

TeamPlayers_home <- CBIND_MultipleCol_n(TP_home, 1, 5)
TeamPlayers_away <- CBIND_MultipleCol_n(TP_away, 1, 5)

TeamPlayers <- rbind(TeamPlayers_home, TeamPlayers_away) %>%
  as.data.frame() %>%
  `colnames<-`(c("Team", "Player")) %>%
  arrange(Team) %>%
  unique()

Players_Sorted_byTeam <- TeamPlayers$Player

Lineups_PasteSort <- function(x) {
  paste(sort(x), collapse = " - ")
}

lineup_home <- df_pbp %>% select(contains("home_p"))
lineup_away <- df_pbp %>% select(contains("away_p"))
lineups     <- cbind(lineup_home, lineup_away)

lineup_home_sorted <- apply(lineup_home, 1, Lineups_PasteSort)
lineup_away_sorted <- apply(lineup_away, 1, Lineups_PasteSort)
lineups_sorted     <- apply(lineups, 1, Lineups_PasteSort)

#lineups
df_lineups_sorted <- df_pbp %>%
  mutate(lineup = lineups_sorted,
    lineup_home = lineup_home_sorted,
    lineup_away = lineup_away_sorted
  ) %>% select(-contains("_player"))

df_merged <- df_lineups_sorted %>%
  mutate(game_code = paste0("G", str_pad(game_code, 6, pad = "0")), 
                     quarter   = paste0("Q", quarter)) %>%
  unite("SeasonGame", c("season", "game_code"))

df_stints <- df_merged %>%
  arrange(SeasonGame) %>%
  mutate(StintChanged = (lineup != lag(lineup)),
         StintChanged = replace_na(StintChanged, TRUE),
         stint        = cumsum(StintChanged))

df_reduced <- df_stints %>%
  mutate(StintRemove  = (stint == lead(stint)),
         StintRemove  = replace_na(StintRemove, FALSE)) %>%
  filter(StintRemove != TRUE)

PlusMinus_function <- function(h,a){
  (h-lag(h))-(a-lag(a))
}

#Home como referencia
df_PlusMinus <- df_reduced %>%
  group_by(SeasonGame) %>%
  mutate(
    stint_seconds = ifelse(is.na(lag(seconds)), seconds, seconds - lag(seconds)),
    PlusMinus  = ifelse(is.na(lag(seconds)), points_home - points_away,
                       PlusMinus_function(points_home, points_away))
  ) %>% ungroup()

df_PlusMinus_reduced <- df_PlusMinus %>% 
  select(c(SeasonGame, quarter, lineup, lineup_home, lineup_away, stint_seconds, PlusMinus)) 

#Eliminar stints duplicados
df_PlusMinus_reduced_bylineups <- df_PlusMinus_reduced %>% 
  group_by(SeasonGame, quarter, lineup, lineup_home, lineup_away) %>% 
  summarise(
    stint_seconds = sum(stint_seconds),
    PlusMinus  = sum(PlusMinus) ) %>% 
  ungroup() %>%
  as.data.frame()

#10min
df_dummys_H <- fastDummies::dummy_cols(df_PlusMinus_reduced_bylineups, 
                                       select_columns = "lineup_home", 
                                       split = "-")
df_dummys_A <- fastDummies::dummy_cols(df_PlusMinus_reduced_bylineups, 
                                       select_columns = "lineup_away", 
                                       split = "-") %>% 
                  mutate(across(starts_with("lineup_away_"), function(x) -x))

Remove_firsts_chars_colnames <- function(data, char){
  num_char <- nchar(char)+1
  substring(names(data), num_char)
}

COL_From <- function(data, first_col){
  last_col = ncol(data)
  colnames(data[first_col:last_col])
}

COL_to <- function(data, first_col, char){
  last_col = ncol(data)
  Remove_firsts_chars_colnames(data[first_col:last_col], char)
}

#Primera columna con el nombre de un jugador
match <- match(paste0("lineup_away_", players), names(df_dummys_A)) %>%
            na.omit() %>%
            min()

#match = 8

#nombre columnas sin primeras palabras:
col_to_A <- COL_to(df_dummys_A, match, "lineup_away_")
col_to_H <- COL_to(df_dummys_H, match, "lineup_home_")

df_dummys_A <- df_dummys_A %>% rename_at(vars(COL_From(df_dummys_A,match)), function(x) col_to_A)
df_dummys_H <- df_dummys_H %>% rename_at(vars(COL_From(df_dummys_H,match)), function(x) col_to_H)

#Juntar los dos DF:
df_dummys_A[df_dummys_A == 0] <- NA
df_dummys_H[df_dummys_H == 0] <- NA

df_dummys <- coalesce(df_dummys_H,df_dummys_A)
df_dummys[is.na(df_dummys)] <- 0

df_dummys <- df_dummys %>% select(-c(starts_with("lineup_"))) %>% ungroup()

df_dummys_PlusMinus <- df_dummys %>%
  group_by(SeasonGame, quarter, lineup, stint_seconds) %>%
  mutate(across(matches(players), function(x) x*PlusMinus)) %>%
  select(-c(PlusMinus)) %>%
  ungroup()

### MasMenos de los mismos lineups (sin tener en cuenta SeasonGame o Quarter):

df_dummys_PlusMinus_2 <- df_dummys_PlusMinus %>% select(-c(SeasonGame, quarter))

PlusMinus_Lineups <- aggregate(. ~ lineup, df_dummys_PlusMinus_2, sum, na.rm = TRUE) %>%
                     mutate(stint_seconds = Print_MS(stint_seconds))

PlusMinus_Classic <- colSums(PlusMinus_Lineups[3:ncol(PlusMinus_Lineups)])

PlusMinus_Classic_df <- as.data.frame(PlusMinus_Classic)

PlusMinus_Classic_df <- PlusMinus_Classic_df %>%
  mutate(Players = rownames(PlusMinus_Classic_df)) %>%
  arrange(Players) %>%
  select(Players, PlusMinus_Classic)
  
rownames(PlusMinus_Classic_df) <- NULL

t<-table(PlusMinus_Classic)

df_dummys %>%
select(stint_seconds) %>%
  apply(1, function(x) x < 1) %>%
  sum()

#2072 entrades amb seconds=0. Mal recogidos los datos. No se tiene en cuenta segundos reales, sino minutos (60,120, 180...). por lo que al hacer la resta con la jugada anterior aparece 0.

df_dummys2 <- df_dummys  
df_dummys2$stint_seconds[df_dummys2$stint_seconds == 0] <- 30 
#df_dummys2 <- df_dummys2 %>% drop_na()


mod1 <- lm(PlusMinus ~ . -SeasonGame -quarter -lineup -stint_seconds, data=df_dummys)
sum1  <- summary(mod1)
coef1 <- as.data.frame(summary(mod1)$coefficients) %>%
  arrange(Estimate)
  
mod2 <- lm(PlusMinus/stint_seconds ~ . -SeasonGame -quarter -lineup, data=df_dummys2)
sum2  <- summary(mod2)
coef2 <- as.data.frame(summary(mod2)$coefficients) %>%
  arrange(Estimate)

mod3 <- lm(PlusMinus/stint_seconds ~ . +lag(PlusMinus) -SeasonGame -quarter -lineup, 
           data=df_dummys2)
sum3  <- summary(mod3)
coef3 <- as.data.frame(summary(mod3)$coefficients) %>%
  arrange(Estimate)


match_firstplayer <- match(players, names(df_dummys_PlusMinus)) %>%
            na.omit() %>%
            min()
n <- dim(df_dummys_PlusMinus)[2]

correlations <- round(cor(model.matrix(~.-1, data=df_dummys_PlusMinus[,match_firstplayer:n])), 5)
@


\section{Análisis y métodos}

\subsection{Descripción de la base de datos}

En este estudio vamos a analizar los datos de todas las jugadas registradas en partidos oficiales de la temporada 2018 de la Liga Nacional de ACB para buscar el Más/Menos Ajustado. Tenemos un total de $N=$ \Sexpr{N_df} jugadas, y \Sexpr{num_players} jugadores en \Sexpr{num_teams} equipos.







\addcontentsline{toc}{section}{Referencias}

\begin{thebibliography}{X}
	\bibitem{RAPM} \textsc{Joseph Sill}, \textit{Improved NBA Adjusted +/- Using Regularization and Out-of-Sample Testing}, PDF, 6 Marzo 2010.
	
	\bibitem{HappyGH} \textsc{Happy Git}, \textit{Let’s Git started}, url: \url{https://happygitwithr.com/index.html}, .
\end{thebibliography}

\clearpage

\section{Annexo}

\subsection{Descripción de las variables} \label{sec:Annexo1}

\begin{itemize}
\item MIN (\emph{Minutes}): Minutos totales jugados
\item PTS (\emph{Points}): Puntos totales realizados
\item 2FGA (\emph{2-point Field Goals Attempted}): Número de tiros de 2 puntos intentadas
\item 2FGM (\emph{2-point Field Goals Made}): Número de tiros de 2 puntos anotadas
\item 3FGA (\emph{3-point Field Goals Attempted}): Número de tiros de 3 puntos ("triples") intentadas
\item 3FGM (\emph{3-point Field Goals Made}): Número de tiros de 3 puntos ("triples") anotadas
\item FTA (\emph{Free Throws Attempted}): Número de tiros libres intentados
\item FTM (\emph{Free Throws Made}): Número de tiros libres anotados
\end{itemize}

\clearpage

\subsection{Code}

\textbf{Datos}

<<>>=
library(readr)
library(dplyr)
library(ggplot2)
library(here)
library(tidyverse)
library(tidyr)
library(dplyr)
library(chron)                 # Para CHR_to_seconds
library(stringr)               # Para str_pad
library(lubridate)
library(reshape)
library(tidyselect)
library(corrplot)
library(RColorBrewer)
library("colorspace")
library(graphics)
library(rpart)
library(ggplot2)
library(car)                   # VIF

#ERROR SOLUCION
pbp_2008 <- read_csv("pbp2008.csv")

## Check how many rows are affected by this
bad_lineups <- pbp_2008 %>%
  select(matches("_player[1-5]")) %>%
  apply(1, function(x) max(table(x)) > 1)

pbp_bad <- pbp_2008 %>%
  filter(bad_lineups)
    
pbp_bad %>%
  select(season, game_code, play_number, play_type, away_player4, away_player5)
    
## Solucion
source(here("R", "fix-lineups.R"))

## Function fix_lineups() only takes data from a single game,
## so I split the data and apply the function to each splitted data frame.
pbp_2008_fixed <- split(pbp_2008, factor(pbp_2008$game_code)) %>%
  map_df(fix_lineups) 

pbp_2009 <- read_csv("pbp2009.csv")
pbp_2009_fixed <- split(pbp_2009, factor(pbp_2009$game_code)) %>%
  map_df(fix_lineups) 

pbp_2010 <- read_csv("pbp2010.csv")
pbp_2010_fixed <- split(pbp_2010, factor(pbp_2010$game_code)) %>%
  map_df(fix_lineups) 

pbp_2011 <- read_csv("pbp2011.csv")
pbp_2011_fixed <- split(pbp_2011, factor(pbp_2011$game_code)) %>%
  map_df(fix_lineups) 

pbp_2012 <- read_csv("pbp2012.csv")
pbp_2012_fixed <- split(pbp_2012, factor(pbp_2012$game_code)) %>%
  map_df(fix_lineups) 

pbp_2013 <- read_csv("pbp2013.csv")
pbp_2013_fixed <- split(pbp_2013, factor(pbp_2013$game_code)) %>%
  map_df(fix_lineups) 

pbp_2014 <- read_csv("pbp2014.csv")
pbp_2014_fixed <- split(pbp_2014, factor(pbp_2014$game_code)) %>%
  map_df(fix_lineups) 

pbp_2015 <- read_csv("pbp2015.csv")
pbp_2015_fixed <- split(pbp_2015, factor(pbp_2015$game_code)) %>%
  map_df(fix_lineups) 

pbp_2017 <- read_csv("pbp2017.csv")
pbp_2017_fixed <- split(pbp_2017, factor(pbp_2017$game_code)) %>%
  map_df(fix_lineups) 

pbp_2018 <- read_csv("pbp2018.csv")
pbp_2018_fixed <- split(pbp_2018, factor(pbp_2018$game_code)) %>%
  map_df(fix_lineups) 

pbd_datos_fixed <- pbp_2008_fixed

factor_names <- c('season', 'game_code', 'team_code', 'play_number', 'play_type')
pbd_datos_fixed[,factor_names] <- lapply(pbd_datos_fixed[,factor_names] , factor)

summary(pbd_datos_fixed[1:18])
@

\textbf{Categorización y edición de BBDD}

<<>>=
#CATEGORIZACION BBDD
df <- pbd_datos_fixed
N_df <- dim(df)[1] # Numero de jugadas
M_df <- dim(df)[2] # Numero de variables

df_fact <- df %>%
  select(season, game_code, team_code, player_name, team_name) %>%
  mutate(season = as.factor(season),
         team_code = as.factor(team_code),
         player_name = as.factor(player_name),
         team_name = as.factor(team_name))

num_teams <- length(levels(df_fact$team_name)) # Numero de equipos

# Lista de jugadores:
players <- df %>% 
  select(matches("player_name")) %>%
  arrange(player_name) %>% 
  unique() %>% 
  drop_na()

players <- players$player_name
num_players <- length(players)   # Numero de jugadores

df_pbp <- df %>% 
  select(season, game_code, quarter, seconds, points_home, points_away, home_team, away_team, matches("_player[1-5]"))
@

textbf{Modificar variable tiempo} 

Para facilitar los calculos con el tiempo, se va a pasar los mm:ss a segundos. 

\begin{itemize}
\item CHR\_to\_seconds: Para pasar la variable tiempo que nos llega como chracter a segundos.
\item Print\_MS: Que nos devolverá los segundos a formato mm:SS (se hará servir más adelante)

\end{itemize}

<<>>=
CHR_to_seconds <- function(x){
  a <- as.POSIXct(x, tz = '', format = "%H:%M:%S", usetz = FALSE)
  tms <- secondss(format(a, "%H:%M:%S"))
  s <- period_to_seconds(hms(tms))
  return(s)
}

Print_MS <- function(x){
  t <- seconds_to_period(x)
  sprintf('%02d:%02d:%02d', t@hour, minute(t), second(t))
}
@

\textbf{Lista Jugadores-Equipo}

<<>>=
TP_home <- df_pbp %>%
  select(c(contains("home_"))) %>%
  unique()

TP_away <- df_pbp %>%
  select(c(contains("away_"))) %>%
  unique()

CBIND_MultipleCol_n <- function(data,col,n){
  d <- unlist(data[col])
  x <- cbind(rep(d, n))
  y <- unlist(data[-1])

  res <- cbind(x, y)
  rownames(res) <- NULL
  
  res <- unique(res)
  
  return(res)
}

TeamPlayers_home <- CBIND_MultipleCol_n(TP_home, 1, 5)
TeamPlayers_away <- CBIND_MultipleCol_n(TP_away, 1, 5)

TeamPlayers <- rbind(TeamPlayers_home, TeamPlayers_away) %>%
  as.data.frame() %>%
  `colnames<-`(c("Team", "Player")) %>%
  arrange(Team) %>%
  unique()

Players_Sorted_byTeam <- TeamPlayers$Player
@

\textbf{Lineups}

Se crea variable \emph{lineups} que recoge los quintetos de ambos equipos en pista.


<<>>=
Lineups_PasteSort <- function(x) {
  paste(sort(x), collapse = " - ")
}

lineup_home <- df_pbp %>% select(contains("home_p"))
lineup_away <- df_pbp %>% select(contains("away_p"))
lineups     <- cbind(lineup_home, lineup_away)

lineup_home_sorted <- apply(lineup_home, 1, Lineups_PasteSort)
lineup_away_sorted <- apply(lineup_away, 1, Lineups_PasteSort)
lineups_sorted     <- apply(lineups, 1, Lineups_PasteSort)

#lineups
df_lineups_sorted <- df_pbp %>%
  mutate(lineup = lineups_sorted,
    lineup_home = lineup_home_sorted,
    lineup_away = lineup_away_sorted
  ) %>% select(-contains("_player"))
@

\textbf{MERGE Temporada+game_code}

Se modifica variable \emph{game\_code} para que quede categorizada con el mismo numero de caracteres. Y unimos \emph{Season} y \emph{Game\_Code} para tener una variable identificadora del partido.

<<>>=
df_merged <- df_lineups_sorted %>%
  mutate(game_code = paste0("G", str_pad(game_code, 6, pad = "0")), 
                     quarter   = paste0("Q", quarter)) %>%
  unite("SeasonGame", c("season", "game_code"))
@

\textbf{Quintetos (Stints)}

Queremos obtener un df con los quintetos identificados cada vez que se produce un cambio. Se dejaran aquellos que esten duplicados ya que es necesario diferenciarlos para posteriormente poder hacer el Mas/Menos correctamente. 

<<>>=
df_stints <- df_merged %>%
  arrange(SeasonGame) %>%
  mutate(StintChanged = (lineup != lag(lineup)),
         StintChanged = replace_na(StintChanged, TRUE),
         stint        = cumsum(StintChanged))

df_reduced <- df_stints %>%
  mutate(StintRemove  = (stint == lead(stint)),
         StintRemove  = replace_na(StintRemove, FALSE)) %>%
  filter(StintRemove != TRUE)
@

\textbf{Más/Menos}

Obtenemos el Mas/Menos segun cada stint. Se tendrá en cuenta el cambio de partido.
Además, esta variable estara hecha con HOME como referencia, pero eso no hace ninguna diferencia estadística importante en nuestro resultado final.


<<>>=
PlusMinus_function <- function(h,a){
  (h-lag(h))-(a-lag(a))
}

#Home como referencia
df_PlusMinus <- df_reduced %>%
  group_by(SeasonGame) %>%
  mutate(
    stint_seconds = ifelse(is.na(lag(seconds)), seconds, seconds - lag(seconds)),
    PlusMinus  = ifelse(is.na(lag(seconds)), points_home - points_away,
                       PlusMinus_function(points_home, points_away))
  ) %>% ungroup()

df_PlusMinus_reduced <- df_PlusMinus %>% 
  select(c(SeasonGame, quarter, lineup, lineup_home, lineup_away, stint_seconds, PlusMinus)) 

#Eliminar stints duplicados
df_PlusMinus_reduced_bylineups <- df_PlusMinus_reduced %>% 
  group_by(SeasonGame, quarter, lineup, lineup_home, lineup_away) %>% 
  summarise(
    stint_seconds = sum(stint_seconds),
    PlusMinus  = sum(PlusMinus) ) %>% 
  ungroup() %>%
  as.data.frame()
@

\subsection{PARTE 2: Dummys Jugadores}

<<>>=
#10min aprox
df_dummys_H <- fastDummies::dummy_cols(df_PlusMinus_reduced_bylineups, 
                                       select_columns = "lineup_home", 
                                       split = "-")
df_dummys_A <- fastDummies::dummy_cols(df_PlusMinus_reduced_bylineups, 
                                       select_columns = "lineup_away", 
                                       split = "-") %>% 
                  mutate(across(starts_with("lineup_away_"), function(x) -x))

Remove_firsts_chars_colnames <- function(data, char){
  num_char <- nchar(char)+1
  substring(names(data), num_char)
}

COL_From <- function(data, first_col){
  last_col = ncol(data)
  colnames(data[first_col:last_col])
}

COL_to <- function(data, first_col, char){
  last_col = ncol(data)
  Remove_firsts_chars_colnames(data[first_col:last_col], char)
}

#Primera columna con el nombre de un jugador
match <- match(paste0("lineup_away_", players), names(df_dummys_A)) %>%
            na.omit() %>%
            min()

#match = 8

#nombre columnas sin primeras palabras:
col_to_A <- COL_to(df_dummys_A, match, "lineup_away_")
col_to_H <- COL_to(df_dummys_H, match, "lineup_home_")

df_dummys_A <- df_dummys_A %>% rename_at(vars(COL_From(df_dummys_A,match)), function(x) col_to_A)
df_dummys_H <- df_dummys_H %>% rename_at(vars(COL_From(df_dummys_H,match)), function(x) col_to_H)

#Juntar los dos DF:
df_dummys_A[df_dummys_A == 0] <- NA
df_dummys_H[df_dummys_H == 0] <- NA

df_dummys <- coalesce(df_dummys_H,df_dummys_A)
df_dummys[is.na(df_dummys)] <- 0

df_dummys <- df_dummys %>% select(-c(starts_with("lineup_"))) %>% ungroup()
@

Ahora mismo tenemos un DF con el PlusMinus con HOME como referencia (si es positivo, ganaban HOME. Si es Negativo ganaban AWAY). Luego tenemos variables "dummys" con $1$ si estaban jugando como HOME, $-1$ si estaban jugando como AWAY y $0$ si no estaban en pista.

\subsection{PARTE 3: PlusMinus por stint (PlusMinus CLASSIC)}

<<>>=
df_dummys_PlusMinus <- df_dummys %>%
  group_by(SeasonGame, quarter, lineup, stint_seconds) %>%
  mutate(across(matches(players), function(x) x*PlusMinus)) %>%
  select(-c(PlusMinus)) %>%
  ungroup()

### MasMenos de los mismos lineups (sin tener en cuenta SeasonGame o Quarter):

df_dummys_PlusMinus_2 <- df_dummys_PlusMinus %>% select(-c(SeasonGame, quarter))

PlusMinus_Lineups <- aggregate(. ~ lineup, df_dummys_PlusMinus_2, sum, na.rm = TRUE) %>%
                     mutate(stint_seconds = Print_MS(stint_seconds))

PlusMinus_Classic <- colSums(PlusMinus_Lineups[3:ncol(PlusMinus_Lineups)])

PlusMinus_Classic_df <- as.data.frame(PlusMinus_Classic)

PlusMinus_Classic_df <- PlusMinus_Classic_df %>%
  mutate(Players = rownames(PlusMinus_Classic_df)) %>%
  arrange(Players) %>%
  select(Players, PlusMinus_Classic)
  
rownames(PlusMinus_Classic_df) <- NULL
@

Graficos:

<<>>=
ggplot(PlusMinus_Classic_df, aes(x=Players, y=PlusMinus_Classic, fill=Players)) +
  geom_bar(stat="identity")+theme_minimal() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

## Este util para grupos pequeños de jugadores. Quizas seria util añadir variable equipo y hacer lo mismo pero por equipos.

t<-table(PlusMinus_Classic); t

plot(t)

ggplot(PlusMinus_Classic_df, aes(x = PlusMinus_Classic)) +
  stat_function(
    fun = dnorm, 
    args = with(PlusMinus_Classic_df, c(mean = mean(PlusMinus_Classic), 
                                      sd = sd(PlusMinus_Classic)))
  ) + scale_x_continuous("Más/Menos clásico")
@

\subsection{PARTE 4: Modelar}

<<>>=
df_dummys %>%
select(stint_seconds) %>%
  apply(1, function(x) x < 1) %>%
  sum()

#2072 entrades amb seconds=0. Mal recogidos los datos. No se tiene en cuenta segundos reales, sino minutos (60,120, 180...). por lo que al hacer la resta con la jugada anterior aparece 0.

df_dummys2 <- df_dummys  
df_dummys2$stint_seconds[df_dummys2$stint_seconds == 0] <- 30 
#df_dummys2 <- df_dummys2 %>% drop_na()


mod1 <- lm(PlusMinus ~ . -SeasonGame -quarter -lineup -stint_seconds, data=df_dummys)
sum1  <- summary(mod1)
coef1 <- as.data.frame(summary(mod1)$coefficients) %>%
  arrange(Estimate)
  
mod2 <- lm(PlusMinus/stint_seconds ~ . -SeasonGame -quarter -lineup, data=df_dummys2)
sum2  <- summary(mod2)
coef2 <- as.data.frame(summary(mod2)$coefficients) %>%
  arrange(Estimate)

mod3 <- lm(PlusMinus/stint_seconds ~ . +lag(PlusMinus) -SeasonGame -quarter -lineup, 
           data=df_dummys2)
sum3  <- summary(mod3)
coef3 <- as.data.frame(summary(mod3)$coefficients) %>%
  arrange(Estimate)
@

\subsection{PARTE 5: HeatMap Correlaciones Jugadores}

Primero vamos a preparar los datos con la estructura que necesitamos para crear el heatmap:


<<>>=
match_firstplayer <- match(players, names(df_dummys_PlusMinus)) %>%
            na.omit() %>%
            min()
n <- dim(df_dummys_PlusMinus)[2]
@


<<>>=
correlations <- round(cor(model.matrix(~.-1, data=df_dummys_PlusMinus[,match_firstplayer:n])), 5)

corrplot(correlations, type = "upper", tl.col = "black", tl.srt = 90, tl.cex = 0.2)

col<- colorRampPalette(c("red", "white", "blue"))(20)
#heatmap(x = correlations, col = col, symm = TRUE)
@

\subsection{PARTE 6: Variance Inflation Factor (VIF)}
<<>>=
#vif(mod1)
@


\end{document}
